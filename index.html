                    <!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <title>Rialo Explorer</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; }
    #scoreboard {
      position: fixed;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 18px;
      font-family: Arial, sans-serif;
      background: rgba(0,0,0,0.5);
      padding: 8px 12px;
      border-radius: 6px;
      z-index: 10;
    }
    #message {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: yellow;
      font-size: 16px;
      background: rgba(0,0,0,0.6);
      padding: 6px 12px;
      border-radius: 6px;
      display: none;
      z-index: 10;
    }
    #hint {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #ddd;
      background: rgba(0,0,0,0.6);
      padding: 8px 12px;
      border-radius: 6px;
      z-index: 9;
    }
    #minimap {
      position: fixed;
      top: 10px;
      right: 10px;
      border: 2px solid white;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="scoreboard">Rialo Points: 0</div>
  <div id="message"></div>
  <div id="hint">Click to lock pointer â€” WASD move, E gather, C craft</div>
  <canvas id="minimap" width="150" height="150"></canvas>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js";
    import { PointerLockControls } from "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/controls/PointerLockControls.js";

    // === SCENE ===
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);

    // CAMERA
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 5);

    // RENDERER
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // CONTROLS
    const controls = new PointerLockControls(camera, document.body);
    scene.add(controls.getObject());
    const hint = document.getElementById("hint");
    document.body.addEventListener("click", () => controls.lock());
    controls.addEventListener("lock", () => { hint.style.display = "none"; });
    controls.addEventListener("unlock", () => { hint.style.display = "block"; });

    // LIGHTS
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(10, 10, 10);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x404040));

    // GROUND
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(100, 100),
      new THREE.MeshPhongMaterial({ color: 0x228833 })
    );
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    // RESOURCES
    const resourceNodes = [];
    const resourceGroup = new THREE.Group();
    scene.add(resourceGroup);

    function spawnResource(x, z) {
      const geo = new THREE.BoxGeometry(1, 1, 1);
      const mat = new THREE.MeshPhongMaterial({ color: 0x8844ff });
      const cube = new THREE.Mesh(geo, mat);
      cube.position.set(x, 0.5, z);
      cube.userData.isDestroying = false;
      resourceGroup.add(cube);
      resourceNodes.push(cube);
    }
    for (let i = 0; i < 20; i++) {
      spawnResource((Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50);
    }

    // SCORE
    let score = 0;
    const scoreboard = document.getElementById("scoreboard");
    const message = document.getElementById("message");
    function updateScore() {
      scoreboard.innerText = "Rialo Points: " + score;
    }
    function flashMessage(text) {
      message.innerText = text;
      message.style.display = "block";
      setTimeout(() => { message.style.display = "none"; }, 1500);
    }

    // AUDIO CONTEXT
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playBeep(freq = 440, duration = 0.2, type = "sine") {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start();
      gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
      osc.stop(audioCtx.currentTime + duration);
    }

    // PARTICLES
    const activeParticles = [];
    const particleGeom = new THREE.SphereGeometry(0.05, 6, 6);
    function spawnParticles(position, color = 0xaa44ff) {
      for (let i = 0; i < 15; i++) {
        const mat = new THREE.MeshBasicMaterial({ color, transparent: true });
        const p = new THREE.Mesh(particleGeom, mat);
        p.position.copy(position);
        p.userData.velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 2,
          Math.random() * 2,
          (Math.random() - 0.5) * 2
        );
        p.userData.life = 1.0;
        scene.add(p);
        activeParticles.push(p);
      }
    }
    function updateParticles(delta) {
      for (let i = activeParticles.length - 1; i >= 0; i--) {
        const p = activeParticles[i];
        p.position.addScaledVector(p.userData.velocity, delta);
        p.userData.velocity.multiplyScalar(0.95);
        p.userData.life -= delta;
        p.material.opacity = Math.max(0, p.userData.life);
        if (p.userData.life <= 0) {
          if (p.material) p.material.dispose();
          scene.remove(p);
          activeParticles.splice(i, 1);
        }
      }
    }

    // INPUT
    const keys = {};
    window.addEventListener("keydown", e => keys[e.code] = true);
    window.addEventListener("keyup", e => keys[e.code] = false);

    function gatherResource() {
      let closest = null, dist = 2;
      for (let node of resourceNodes) {
        if (node.userData.isDestroying) continue;
        const d = camera.position.distanceTo(node.position);
        if (d < dist) { dist = d; closest = node; }
      }
      if (closest) {
        closest.userData.isDestroying = true;
        flashMessage("Resource Collected!");
        score += 5;
        updateScore();
        spawnParticles(closest.position);
        playBeep(600, 0.15, "square"); // ðŸŽµ Ð·Ð²ÑƒÐº Ð·Ð±Ð¸Ñ€Ð°Ð½Ð½Ñ
      } else {
        flashMessage("No resource nearby");
      }
    }
    function craftToken() {
      if (score >= 5) {
        score -= 5;
        score += 10;
        updateScore();
        flashMessage("Crafted Rialo Token!");
        playBeep(300, 0.25, "sawtooth"); // ðŸŽµ Ð·Ð²ÑƒÐº ÐºÑ€Ð°Ñ„Ñ‚Ñƒ
      } else {
        flashMessage("Not enough resources!");
        playBeep(150, 0.3, "triangle"); // âŒ Ð½Ð¸Ð·ÑŒÐºÐ¸Ð¹ Ð·Ð²ÑƒÐº
      }
    }
    window.addEventListener("keydown", e => {
      if (e.code === "KeyE") gatherResource();
      if (e.code === "KeyC") craftToken();
    });

    // MOVEMENT
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const moveSpeed = 5.0;
    function move(delta) {
      direction.set(0, 0, 0);
      if (keys["KeyW"]) direction.z -= 1;
      if (keys["KeyS"]) direction.z += 1;
      if (keys["KeyA"]) direction.x -= 1;
      if (keys["KeyD"]) direction.x += 1;

      if (direction.length() > 0) {
        direction.normalize();
        direction.applyQuaternion(camera.quaternion);
        direction.y = 0;
        direction.normalize();
        velocity.copy(direction).multiplyScalar(moveSpeed * delta);
        controls.getObject().position.add(velocity);
      }
    }

    // RESIZE
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // MINI-MAP
    const minimap = document.getElementById("minimap");
    const ctx = minimap.getContext("2d");
    function drawMinimap() {
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, minimap.width, minimap.height);

      // Ð³Ñ€Ð°Ð²ÐµÑ†ÑŒ Ñƒ Ñ†ÐµÐ½Ñ‚Ñ€Ñ–
      const centerX = minimap.width / 2;
      const centerY = minimap.height / 2;

      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.arc(centerX, centerY, 4, 0, Math.PI * 2);
      ctx.fill();

      // Ñ€ÐµÑÑƒÑ€ÑÐ¸
      ctx.fillStyle = "blue";
      for (let node of resourceNodes) {
        if (node.userData.isDestroying) continue;
        const dx = node.position.x - camera.position.x;
        const dz = node.position.z - camera.position.z;
        const scale = 2.5; // Ð¼Ð°ÑÑˆÑ‚Ð°Ð± ÐºÐ°Ñ€Ñ‚Ð¸
        const x = centerX + dx / scale;
        const y = centerY + dz / scale;
        if (x >= 0 && x <= minimap.width && y >= 0 && y <= minimap.height) {
          ctx.fillRect(x - 2, y - 2, 4, 4);
        }
      }
    }

    // LOOP
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      for (let i = resourceNodes.length - 1; i >= 0; i--) {
        const node = resourceNodes[i];
        if (node.userData.isDestroying) {
          node.scale.multiplyScalar(0.85);
          if (node.scale.x < 0.1) {
            resourceGroup.remove(node);
            if (node.geometry) node.geometry.dispose();
            if (node.material) node.material.dispose();
            resourceNodes.splice(i, 1);
          }
        }
      }

      updateParticles(delta);
      if (controls.isLocked) move(delta);
      renderer.render(scene, camera);

      // Ð¼Ñ–Ð½Ñ–-Ð¼Ð°Ð¿Ð°
      drawMinimap();
    }
    animate();
  </script>
</body>
</html>
