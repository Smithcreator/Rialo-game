<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <title>Rialo Explorer</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; }
    #scoreboard {
      position: fixed;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 18px;
      font-family: Arial, sans-serif;
      background: rgba(0,0,0,0.5);
      padding: 8px 12px;
      border-radius: 6px;
      z-index: 10;
    }
    #message {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: yellow;
      font-size: 16px;
      background: rgba(0,0,0,0.6);
      padding: 6px 12px;
      border-radius: 6px;
      display: none;
      z-index: 10;
    }
    /* optional: cursor hint when not locked */
    #hint {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #ddd;
      background: rgba(0,0,0,0.6);
      padding: 8px 12px;
      border-radius: 6px;
      z-index: 9;
    }
  </style>
</head>
<body>
  <div id="scoreboard">Rialo Points: 0</div>
  <div id="message"></div>
  <div id="hint">Click to lock pointer â€” Use WASD to move, E gather, C craft</div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js";
    import { PointerLockControls } from "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/controls/PointerLockControls.js";

    // Scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);

    // Camera
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 5);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Controls
    const controls = new PointerLockControls(camera, document.body);
    const hint = document.getElementById('hint');
    document.body.addEventListener("click", () => {
      controls.lock();
    });
    controls.addEventListener('lock', () => { hint.style.display = 'none'; });
    controls.addEventListener('unlock', () => { hint.style.display = 'block'; });

    // Lights
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(10, 10, 10);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x404040));

    // Ground
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(100, 100),
      new THREE.MeshPhongMaterial({ color: 0x228833 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Resources
    const resourceNodes = [];
    const resourceGroup = new THREE.Group();
    scene.add(resourceGroup);

    function spawnResource(x, z) {
      const geo = new THREE.BoxGeometry(1, 1, 1);
      const mat = new THREE.MeshPhongMaterial({ color: 0x8844ff });
      const cube = new THREE.Mesh(geo, mat);
      cube.position.set(x, 0.5, z);
      cube.userData.isDestroying = false;
      resourceGroup.add(cube);
      resourceNodes.push(cube);
    }

    for (let i = 0; i < 20; i++) {
      spawnResource((Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50);
    }

    // Score
    let score = 0;
    const scoreboard = document.getElementById("scoreboard");
    const message = document.getElementById("message");

    function updateScoreboard() {
      scoreboard.innerText = "Rialo Points: " + score;
    }

    function flashMessage(text) {
      message.innerText = text;
      message.style.display = "block";
      setTimeout(() => { message.style.display = "none"; }, 1500);
    }

    // Particles (reuse geometry & material template)
    const activeParticles = [];
    const particleGeom = new THREE.SphereGeometry(0.05, 6, 6);

    function spawnParticles(position, color = 0xaa44ff) {
      for (let i = 0; i < 15; i++) {
        const mat = new THREE.MeshBasicMaterial({ color, transparent: true });
        const p = new THREE.Mesh(particleGeom, mat);
        p.position.copy(position);
        p.userData.velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 2,
          Math.random() * 2,
          (Math.random() - 0.5) * 2
        );
        p.userData.life = 1.0;
        scene.add(p);
        activeParticles.push(p);
      }
    }

    function updateParticles(delta) {
      for (let i = activeParticles.length - 1; i >= 0; i--) {
        const p = activeParticles[i];
        p.position.addScaledVector(p.userData.velocity, delta);
        p.userData.velocity.multiplyScalar(0.95);
        p.userData.life -= delta;
        p.material.opacity = Math.max(0, p.userData.life);
        if (p.userData.life <= 0) {
          // dispose material to avoid leak
          if (p.material) p.material.dispose();
          scene.remove(p);
          activeParticles.splice(i, 1);
        }
      }
    }

    // Controls input
    const keys = {};
    window.addEventListener("keydown", e => keys[e.code] = true);
    window.addEventListener("keyup", e => keys[e.code] = false);

    function gatherResource() {
      let closest = null, dist = 2;
      for (let node of resourceNodes) {
        if (node.userData.isDestroying) continue;
        const d = camera.position.distanceTo(node.position);
        if (d < dist) { dist = d; closest = node; }
      }
      if (closest) {
        closest.userData.isDestroying = true;
        flashMessage("Resource Collected!");
        score += 5;
        updateScoreboard();
        spawnParticles(closest.position);
      } else {
        flashMessage("No resource nearby");
      }
    }

    function craftToken() {
      // Example: spend 5 points to craft a token that gives +10 (net +5)
      if (score >= 5) {
        score -= 5;    // cost
        score += 10;   // reward
        updateScoreboard();
        flashMessage("Crafted Rialo Token!");
      } else {
        flashMessage("Not enough resources!");
      }
    }

    window.addEventListener("keydown", e => {
      if (e.code === "KeyE") gatherResource();
      if (e.code === "KeyC") craftToken();
    });

    // Movement
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const moveSpeed = 5.0;

    function move(delta) {
      direction.set(0, 0, 0);
      if (keys["KeyW"]) direction.z -= 1;
      if (keys["KeyS"]) direction.z += 1;
      if (keys["KeyA"]) direction.x -= 1;
      if (keys["KeyD"]) direction.x += 1;

      if (direction.length() > 0) {
        direction.normalize();
        // rotate direction by camera yaw but strip vertical component so movement stays horizontal
        direction.applyQuaternion(camera.quaternion);
        direction.y = 0;
        direction.normalize();
        velocity.copy(direction).multiplyScalar(moveSpeed * delta);
        controls.getObject().position.add(velocity);
      }
    }

    // Resize
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Loop
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      // Destroying cubes (scale-down animation and removal)
      for (let i = resourceNodes.length - 1; i >= 0; i--) {
        const node = resourceNodes[i];
        if (node.userData.isDestroying) {
          node.scale.multiplyScalar(0.85);
          if (node.scale.x < 0.1) {
            resourceGroup.remove(node);
            // dispose geometry/material to free memory
            if (node.geometry) node.geometry.dispose();
            if (node.material) node.material.dispose();
            resourceNodes.splice(i, 1);
          }
        }
      }

      updateParticles(delta);
      if (controls.isLocked) move(delta);
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
