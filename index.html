<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Rialo Explorer (working)</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; }
    #scoreboard {
      position: fixed; top: 10px; left: 10px;
      color: white; font-size: 18px; font-family: Arial, sans-serif;
      background: rgba(0,0,0,0.5); padding: 8px 12px; border-radius: 6px;
      z-index: 10;
    }
    #message {
      position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
      color: yellow; font-size: 16px;
      background: rgba(0,0,0,0.6); padding: 6px 12px; border-radius: 6px;
      display: none; z-index: 10;
    }
    #hint {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      color: #ddd; background: rgba(0,0,0,0.6);
      padding: 8px 12px; border-radius: 6px; z-index: 9;
    }
    #minimap {
      position: fixed; top: 10px; right: 10px;
      border: 2px solid white; z-index: 10;
    }
    #controls { position: fixed; bottom: 30px; left: 20px; display: flex; gap: 15px; z-index: 20; }
    #actions { position: fixed; bottom: 30px; right: 20px; display: flex; flex-direction: column; gap: 15px; z-index: 20; }
    .btn {
      width: 60px; height: 60px; border-radius: 50%;
      background: rgba(255,255,255,0.2); border: 2px solid white;
      color: white; font-size: 28px; display:flex;align-items:center;justify-content:center;
      user-select: none;
    }
    .btn:active { background: rgba(255,255,255,0.5); }

    /* Start screen */
    #startScreen {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.9); display: flex; flex-direction: column; justify-content: center; align-items: center;
      z-index: 100; color: white; font-family: Arial, sans-serif;
    }
    #startButton {
      margin-top: 20px; padding: 12px 24px; font-size: 20px; border: 2px solid white;
      background: transparent; color: white; border-radius: 8px; cursor: pointer;
    }
    #startButton:hover { background: rgba(255,255,255,0.2); }

    /* persistent error box for debugging */
    #errorBox {
      position: fixed; top: 70px; left: 10px; right: 10px; color: #fff;
      background: rgba(160,20,20,0.9); padding: 8px 12px; border-radius: 6px; z-index: 200;
      display: none; font-family: monospace; font-size: 13px;
      max-height: 160px; overflow:auto;
    }
  </style>
</head>
<body>
  <div id="scoreboard">Rialo Points: 0</div>
  <div id="message"></div>
  <div id="hint">Click to lock pointer — WASD move, E gather, C craft</div>
  <canvas id="minimap" width="150" height="150"></canvas>

  <!-- Mobile movement -->
  <div id="controls" style="display:none;">
    <div class="btn" data-key="KeyA">⬅️</div>
    <div class="btn" data-key="KeyW">⬆️</div>
    <div class="btn" data-key="KeyS">⬇️</div>
    <div class="btn" data-key="KeyD">➡️</div>
  </div>

  <!-- Mobile actions -->
  <div id="actions" style="display:none;">
    <div class="btn" id="btnE">E</div>
    <div class="btn" id="btnC">C</div>
  </div>

  <!-- Start screen -->
  <div id="startScreen">
    <h1>Rialo Explorer</h1>
    <p>Collect resources (E), craft tokens (C), and explore the world.</p>
    <button id="startButton">Start Game</button>
  </div>

  <div id="errorBox"></div>

  <!-- stable UMD Three.js + PointerLockControls (works when opened locally) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/examples/js/controls/PointerLockControls.js"></script>

  <!-- Main script (non-module for maximum compatibility) -->
  <script>
    (function () {
      // Short helper to show persistent errors
      const errorBox = document.getElementById('errorBox');
      function showError(msg) {
        errorBox.style.display = 'block';
        const time = new Date().toISOString();
        errorBox.innerText = time + " — " + msg + "\n\n" + errorBox.innerText;
        console.error(msg);
      }

      try {
        // Basic globals
        let scene, camera, renderer, controls;
        let resourceNodes = [], resourceGroup;
        let score = 0, audioCtx = null;
        const scoreboard = document.getElementById("scoreboard");
        const message = document.getElementById("message");
        const hint = document.getElementById("hint");
        const startScreen = document.getElementById("startScreen");

        function initGame() {
          try {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);

            // place canvas behind HUD elements
            document.body.insertBefore(renderer.domElement, document.getElementById("scoreboard"));

            // Controls (UMD PointerLockControls attaches to THREE)
            if (typeof THREE.PointerLockControls !== 'function' && typeof THREE.PointerLockControls !== 'object') {
              showError('PointerLockControls not available. Make sure the controls script loaded.');
            }
            controls = new THREE.PointerLockControls(camera, document.body);
            scene.add(controls.getObject());

            const isMobile = /Mobi|Android/i.test(navigator.userAgent);
            if (!isMobile) {
              // Lock on click of the rendered canvas (safer than entire body)
              renderer.domElement.addEventListener('click', () => {
                try { controls.lock(); } catch (err) { console.warn('lock failed', err); }
              });
              controls.addEventListener("lock", () => { hint.style.display = "none"; });
              controls.addEventListener("unlock", () => { hint.style.display = "block"; });
            } else {
              hint.innerText = "Tap arrows to move, E to gather, C to craft";
              document.getElementById("controls").style.display = "flex";
              document.getElementById("actions").style.display = "flex";
            }

            // Lights
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(10, 10, 10);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0x404040));

            // Ground
            const ground = new THREE.Mesh(
              new THREE.PlaneGeometry(100, 100),
              new THREE.MeshPhongMaterial({ color: 0x228833 })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Resources
            resourceGroup = new THREE.Group();
            scene.add(resourceGroup);
            for (let i = 0; i < 20; i++) {
              spawnResource((Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50);
            }

            // Resize handling
            window.addEventListener('resize', onWindowResize);

            animate();
          } catch (e) {
            showError('initGame error: ' + (e && e.message ? e.message : e));
          }
        }

        function onWindowResize() {
          if (!camera || !renderer) return;
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function spawnResource(x, z) {
          const geo = new THREE.BoxGeometry(1, 1, 1);
          const mat = new THREE.MeshPhongMaterial({ color: 0x8844ff });
          const cube = new THREE.Mesh(geo, mat);
          cube.position.set(x, 0.5, z);
          cube.userData.isDestroying = false;
          resourceGroup.add(cube);
          resourceNodes.push(cube);
        }

        function updateScore() {
          scoreboard.innerText = "Rialo Points: " + score;
        }
        function flashMessage(text) {
          message.innerText = text;
          message.style.display = "block";
          setTimeout(() => { message.style.display = "none"; }, 1500);
        }

        function initAudio() {
          if (!audioCtx) {
            try {
              audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
              console.warn('AudioContext not available', e);
            }
          }
        }
        function playBeep(freq = 440, duration = 0.2, type = "sine") {
          if (!audioCtx) return;
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.type = type;
          osc.frequency.value = freq;
          osc.connect(gain);
          gain.connect(audioCtx.destination);
          osc.start();
          gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
          osc.stop(audioCtx.currentTime + duration);
        }

        // Input
        const keys = {};
        window.addEventListener("keydown", e => keys[e.code] = true);
        window.addEventListener("keyup", e => keys[e.code] = false);

        document.querySelectorAll("#controls .btn").forEach(btn => {
          const key = btn.dataset.key;
          btn.addEventListener("touchstart", () => { keys[key] = true; initAudio(); }, { passive: true });
          btn.addEventListener("touchend", () => { keys[key] = false; }, { passive: true });
          // allow clicks as fallback
          btn.addEventListener("mousedown", () => { keys[key] = true; initAudio(); });
          btn.addEventListener("mouseup", () => { keys[key] = false; });
        });

        document.getElementById("btnE").addEventListener("touchstart", () => gatherResource(), { passive: true });
        document.getElementById("btnC").addEventListener("touchstart", () => craftToken(), { passive: true });
        document.getElementById("btnE").addEventListener("mousedown", () => gatherResource());
        document.getElementById("btnC").addEventListener("mousedown", () => craftToken());

        function gatherResource() {
          let closest = null, dist = 2;
          for (let node of resourceNodes) {
            if (node.userData.isDestroying) continue;
            const d = camera.position.distanceTo(node.position);
            if (d < dist) { dist = d; closest = node; }
          }
          if (closest) {
            closest.userData.isDestroying = true;
            flashMessage("Resource Collected!");
            score += 5;
            updateScore();
            playBeep(600, 0.15, "square");
          } else {
            flashMessage("No resource nearby");
            playBeep(220, 0.12, "sine");
          }
        }
        function craftToken() {
          if (score >= 5) {
            score -= 5;
            score += 10;
            updateScore();
            flashMessage("Crafted Rialo Token!");
            playBeep(300, 0.25, "sawtooth");
          } else {
            flashMessage("Not enough resources!");
            playBeep(150, 0.3, "triangle");
          }
        }
        window.addEventListener("keydown", e => {
          if (e.code === "KeyE") gatherResource();
          if (e.code === "KeyC") craftToken();
        });

        // Movement
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const moveSpeed = 5.0;
        function move(delta) {
          if (!controls || !controls.getObject) return;
          direction.set(0, 0, 0);
          if (keys["KeyW"]) direction.z -= 1;
          if (keys["KeyS"]) direction.z += 1;
          if (keys["KeyA"]) direction.x -= 1;
          if (keys["KeyD"]) direction.x += 1;
          if (direction.length() > 0) {
            direction.normalize();
            // move in camera horizontal direction
            const quat = camera.quaternion.clone();
            direction.applyQuaternion(quat);
            direction.y = 0;
            direction.normalize();
            velocity.copy(direction).multiplyScalar(moveSpeed * delta);
            controls.getObject().position.add(velocity);
          }
        }

        // Minimap
        const minimap = document.getElementById("minimap");
        const ctx = minimap.getContext("2d");
        function drawMinimap() {
          ctx.fillStyle = "black";
          ctx.fillRect(0, 0, minimap.width, minimap.height);

          const centerX = minimap.width / 2;
          const centerY = minimap.height / 2;

          ctx.fillStyle = "red";
          ctx.beginPath();
          ctx.arc(centerX, centerY, 4, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = "blue";
          for (let node of resourceNodes) {
            if (node.userData.isDestroying) continue;
            const dx = node.position.x - camera.position.x;
            const dz = node.position.z - camera.position.z;
            const scale = 2.5;
            const x = centerX + dx / scale;
            const y = centerY + dz / scale;
            if (x >= 0 && x <= minimap.width && y >= 0 && y <= minimap.height) {
              ctx.fillRect(x - 2, y - 2, 4, 4);
            }
          }
        }

        // Game loop
        const clock = new THREE.Clock();
        function animate() {
          requestAnimationFrame(animate);
          const delta = clock.getDelta();
          for (let i = resourceNodes.length - 1; i >= 0; i--) {
            const node = resourceNodes[i];
            if (node.userData.isDestroying) {
              node.scale.multiplyScalar(0.85);
              if (node.scale.x < 0.1) {
                resourceGroup.remove(node);
                resourceNodes.splice(i, 1);
              }
            }
          }
          if (controls && (controls.isLocked || /Mobi|Android/i.test(navigator.userAgent))) {
            move(delta);
          }
          if (renderer && camera) renderer.render(scene, camera);
          drawMinimap();
        }

        // Prevent double init of game
        const startBtn = document.getElementById("startButton");
        let started = false;
        startBtn.addEventListener("click", () => {
          if (started) return;
          started = true;
          startBtn.disabled = true;
          startScreen.style.display = "none";
          try {
            initAudio();
            initGame();
          } catch (e) {
            showError('start click error: ' + (e && e.message ? e.message : e));
          }
        });

      } catch (outerErr) {
        showError('Fatal error: ' + (outerErr && outerErr.message ? outerErr.message : outerErr));
      }
    })();
  </script>
</body>
</html>
